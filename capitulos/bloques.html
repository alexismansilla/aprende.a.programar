<!DOCTYPE HTML>
<html lang="es">
    <head prefix="og: http://ogp.me/ns# book: http://ogp.me/ns/book#">
        
        <meta charset="UTF-8">
        <title>Bloques | Aprende a Programar con Ruby</title>

        <meta content="text/html; charset=utf-8" http-equiv="Content-Type">
        <meta name="robots" content="index, follow">
        <meta name="author" content="rubysur">
        <meta name="description" content="Cuando programas una computadora, necesitas &quot;hablar&quot; en la forma que tu
computadora entienda: un lenguaje de programación. Existen diferentes
lenguajes y muchos de ellos son excelentes. En esta guía voy a
usar mi lenguaje de programación favorito: _Ruby_.">
        <meta name="keywords" content="gitbook,github" >
        <meta name="generator" content="www.gitbook.io">

        
        <link rel="next" href="../capitulos/fin.html" />
        
        
        <link rel="prev" href="../capitulos/clases.html" />
        

        <meta property="og:title" content="Bloques | Aprende a Programar con Ruby">
        <meta property="og:site_name" content="Aprende a Programar con Ruby">
        <meta property="og:type" content="book">
        <meta property="og:locale" content="en_US">

        <meta property="book:author" content="https://github.com/rubysur">
        <meta property="book:tag" content="GitBook">

        <meta name="viewport" content="width=device-width, initial-scale=1, user-scalable=no">
        <meta name="apple-mobile-web-app-capable" content="yes">
        <meta name="apple-mobile-web-app-status-bar-style" content="black">

        <link rel="shortcut icon" href="../gitbook/images/favicon.ico" type="image/x-icon">
        
    </head>
    <body>
        
    <div class="book" data-github="rubysur/aprende.a.programar" data-level="10" data-basepath=".." data-revision="1397782757726">
    <div class="book-header">
    <!-- Actions Left -->
    
    <a href="https://github.com/rubysur/aprende.a.programar" target="_blank" class="btn pull-left"><i class="fa fa-github-alt"></i></a>
    
    <a href="#" class="btn pull-left toggle-summary"><i class="fa fa-align-justify"></i></a>
    <a href="#" class="btn pull-left toggle-search"><i class="fa fa-search"></i></a>

    <!-- Actions Right -->
    <a href="#" target="_blank" class="btn pull-right" data-sharing="google-plus"><i class="fa fa-google-plus"></i></a>
    <a href="#" target="_blank" class="btn pull-right" data-sharing="facebook"><i class="fa fa-facebook"></i></a>
    <a href="#" target="_blank" class="btn pull-right" data-sharing="twitter"><i class="fa fa-twitter"></i></a>

    
    <a href="https://github.com/rubysur/aprende.a.programar/stargazers" target="_blank" class="btn pull-right count-star"><i class="fa fa-star-o"></i> Star (<span>-</span>)</a>
    <a href="https://github.com/rubysur/aprende.a.programar/watchers" target="_blank" class="btn pull-right count-watch"><i class="fa fa-eye"></i> Watch (<span>-</span>)</a>
    

    <!-- Title -->
    <h1><a href="../" >Aprende a Programar con Ruby</a></h1>
</div>

    <div class="book-summary">
    <div class="book-search">
        <input type="text" placeholder="Search" class="form-control" />
    </div>
    <ul class="summary">
        
        <li>
            <a href="http://rubysur.org/" target="blank">RubySur</a>
        </li>
        <li>
            <a href="https://github.com/rubysur/aprende.a.programar/issues" target="blank">Preguntas y Errores</a>
        </li>
        <li>
            <a href="https://github.com/rubysur/aprende.a.programar/edit/master/capitulos/bloques.md" target="blank">Edita y Contribuye!</a>
        </li>
        <li class="divider"></li>
        
        <li data-level="0" data-path="index.html">
            <a href="../"><i class="fa fa-check"></i>Introducción</a>
        </li>
        
            <li  data-level="1" data-path="capitulos/numeros.html">
                
                <a href="../capitulos/numeros.html">
                    <i class="fa fa-check"></i> <b>1.</b> Números
                </a>
                
                
            </li>
        
            <li  data-level="2" data-path="capitulos/textos.html">
                
                <a href="../capitulos/textos.html">
                    <i class="fa fa-check"></i> <b>2.</b> Textos
                </a>
                
                
            </li>
        
            <li  data-level="3" data-path="capitulos/variables.html">
                
                <a href="../capitulos/variables.html">
                    <i class="fa fa-check"></i> <b>3.</b> Variables
                </a>
                
                
            </li>
        
            <li  data-level="4" data-path="capitulos/conversiones.html">
                
                <a href="../capitulos/conversiones.html">
                    <i class="fa fa-check"></i> <b>4.</b> Conversiones
                </a>
                
                
            </li>
        
            <li  data-level="5" data-path="capitulos/metodos.html">
                
                <a href="../capitulos/metodos.html">
                    <i class="fa fa-check"></i> <b>5.</b> Métodos
                </a>
                
                
            </li>
        
            <li  data-level="6" data-path="capitulos/condicionales.html">
                
                <a href="../capitulos/condicionales.html">
                    <i class="fa fa-check"></i> <b>6.</b> Condicionales
                </a>
                
                
            </li>
        
            <li  data-level="7" data-path="capitulos/matrices.html">
                
                <a href="../capitulos/matrices.html">
                    <i class="fa fa-check"></i> <b>7.</b> Matrices e Iteraciones
                </a>
                
                
            </li>
        
            <li  data-level="8" data-path="capitulos/metodos_propios.html">
                
                <a href="../capitulos/metodos_propios.html">
                    <i class="fa fa-check"></i> <b>8.</b> Métodos Propios
                </a>
                
                
            </li>
        
            <li  data-level="9" data-path="capitulos/clases.html">
                
                <a href="../capitulos/clases.html">
                    <i class="fa fa-check"></i> <b>9.</b> Clases
                </a>
                
                
            </li>
        
            <li  data-level="10" data-path="capitulos/bloques.html">
                
                <a href="../capitulos/bloques.html">
                    <i class="fa fa-check"></i> <b>10.</b> Bloques
                </a>
                
                
            </li>
        
            <li  data-level="11" data-path="capitulos/fin.html">
                
                <a href="../capitulos/fin.html">
                    <i class="fa fa-check"></i> <b>11.</b> Fin
                </a>
                
                
            </li>
        
            <li  data-level="12" data-path="capitulos/acerca.html">
                
                <a href="../capitulos/acerca.html">
                    <i class="fa fa-check"></i> <b>12.</b> Acerca de
                </a>
                
                
            </li>
        
    </ul>
</div>

    <div class="book-body">
        <div class="body-inner">
            <div class="page-wrapper" tabindex="-1">
                <div class="book-progress">
    <div class="bar">
        <div class="inner" style="width: 16.666666666666668%;min-width: 8.333333333333334%;"></div>
    </div>
    <div class="chapters">
    
        <a href="../index.html" title="Introduction" class="chapter done new-chapter" data-progress="0" style="left: 0%;"></a>
    
        <a href="../capitulos/numeros.html" title="Números" class="chapter done new-chapter" data-progress="1" style="left: 8.333333333333334%;"></a>
    
        <a href="../capitulos/bloques.html" title="Bloques" class="chapter done " data-progress="10" style="left: 16.666666666666668%;"></a>
    
        <a href="../capitulos/fin.html" title="Fin" class="chapter  " data-progress="11" style="left: 25%;"></a>
    
        <a href="../capitulos/acerca.html" title="Acerca de" class="chapter  " data-progress="12" style="left: 33.333333333333336%;"></a>
    
        <a href="../capitulos/textos.html" title="Textos" class="chapter  new-chapter" data-progress="2" style="left: 41.666666666666664%;"></a>
    
        <a href="../capitulos/variables.html" title="Variables" class="chapter  new-chapter" data-progress="3" style="left: 50%;"></a>
    
        <a href="../capitulos/conversiones.html" title="Conversiones" class="chapter  new-chapter" data-progress="4" style="left: 58.333333333333336%;"></a>
    
        <a href="../capitulos/metodos.html" title="Métodos" class="chapter  new-chapter" data-progress="5" style="left: 66.66666666666667%;"></a>
    
        <a href="../capitulos/condicionales.html" title="Condicionales" class="chapter  new-chapter" data-progress="6" style="left: 75%;"></a>
    
        <a href="../capitulos/matrices.html" title="Matrices e Iteraciones" class="chapter  new-chapter" data-progress="7" style="left: 83.33333333333333%;"></a>
    
        <a href="../capitulos/metodos_propios.html" title="Métodos Propios" class="chapter  new-chapter" data-progress="8" style="left: 91.66666666666667%;"></a>
    
        <a href="../capitulos/clases.html" title="Clases" class="chapter  new-chapter" data-progress="9" style="left: 100%;"></a>
    
    </div>
</div>

                <div class="page-inner">
                
                    <section class="normal" id="section-gitbook_8">
                    
                        <h1 id="bloques-y-procedimientos">Bloques y Procedimientos</h1>
<p>Esta es definitivamente una de las mejores herramientas de Ruby.
Algunos lenguajes tienen esta herramienta, pienso que la llamaran
de otra forma (como <em>closures</em>), pero la mayoría de los más
populares no lo hacen, una pena.</p>
<p>Entonces ¿qué es esto que es tan bueno? Esto tiene la habilidad
de tomar un <em>bloque</em> de código (código entre <strong>do</strong>
y <strong>end</strong>) y encapsularlo dentro de un objeto (llamado <em>proc</em>) y
guardarlo en una variable o pasarlo a un método, y ejecutar el código del
bloque donde te guste (más de una vez, si quieres) Entonces esto es
como un tipo método excepto que no está dentro de un objeto
(este bloque <em>es</em> un objeto), y puedes almacenarlo o pasarlo como cualquier
otro objeto. Es hora de un ejemplo:</p>
<p><em>Código:</em></p>
<pre><code>toast = Proc.<span class="hljs-keyword">new</span> <span class="hljs-keyword">do</span>
  puts <span class="hljs-comment">'¡Aplausos!'</span>
<span class="hljs-keyword">end</span>

toast.<span class="hljs-keyword">call</span>
toast.<span class="hljs-keyword">call</span>
toast.<span class="hljs-keyword">call</span>
</code></pre><p><em>Resultado:</em></p>
<pre><code>¡<span class="hljs-variable">Aplausos</span><span class="hljs-exclamation_mark">!</span>
¡<span class="hljs-variable">Aplausos</span><span class="hljs-exclamation_mark">!</span>
¡<span class="hljs-variable">Aplausos</span><span class="hljs-exclamation_mark">!</span>
</code></pre><p>Entonces creé un proc (el cual pienso debería ser pronunciado como &quot;procedimiento&quot;) que
contiene un bloque de código, y llamé (<em>call</em>ed) el proc tres
veces. Como puedes ver, esto es como un método.</p>
<p>En realidad, son más parecidos a los métodos que te he mostrado, porque los bloques pueden
tomar parámetros:</p>
<p><em>Código:</em></p>
<pre><code>teGusta = Proc.new <span class="hljs-operator"><span class="hljs-keyword">do</span> |algoRico|
  puts <span class="hljs-string">'¡Me gusta *realmente* el '</span>+algoRico+<span class="hljs-string">'!'</span>
<span class="hljs-keyword">end</span>

teGusta.<span class="hljs-keyword">call</span> <span class="hljs-string">'chocolate'</span>
teGusta.<span class="hljs-keyword">call</span> <span class="hljs-string">'ruby'</span></span>
</code></pre><p><em>Resultado:</em></p>
<pre><code>¡Me gusta <span class="hljs-emphasis">*realmente*</span> el chocolate!
¡Me gusta <span class="hljs-emphasis">*realmente*</span> el ruby!
</code></pre><p>Muy bien, entonces hemos visto que son los bloques y procs, y como usarlos, pero
¿cuál es el punto? ¿Porqué no utilizar simplemente métodos? Bueno, esto es porque
hay más cosas que no podemos hacer con métodos. En particular, no
puedes pasar métodos a otros métodos (pero puedes pasar procs dentro de métodos),
y métodos no pueden retornar otros métodos (pero ellos pueden retornar procs). Esto
es simplemente porque procs son objetos; los métodos no son objetos</p>
<p>(De hecho, ¿es algo familiar para tí? Sí, tu has visto bloques antes... cuando aprendiste
sobre iteradores. Pero vamos a hablar un poco más acerca de esto en breve)</p>
<h2 id="m-todos-que-reciben-procedimientos">Métodos que reciben Procedimientos</h2>
<p>Cuando pasamos un proc en un método podemos controlar cómo o cuántas veces llamamos
el proc. Por ejemplo, vamos a decir que queremos hacer antes y después de cierto código que
se esta ejecutando:</p>
<p><em>Código:</em></p>
<pre><code>def hacerAlgoImportante unProc
  puts <span class="hljs-string">'¡Todo el mundo DETENGANSE!  Tengo algo que hacer...'</span>
  unProc.call
  puts <span class="hljs-string">'A todos: Está hecho.  Continuen con lo que estaban haciendo.'</span>
<span class="hljs-function"><span class="hljs-keyword">end</span></span>

decirHola = Proc.<span class="hljs-built_in">new</span> <span class="hljs-built_in">do</span>
  puts <span class="hljs-string">'hola'</span>
<span class="hljs-function"><span class="hljs-keyword">end</span></span>

decirAdios = Proc.<span class="hljs-built_in">new</span> <span class="hljs-built_in">do</span>
  puts <span class="hljs-string">'adios'</span>
<span class="hljs-function"><span class="hljs-keyword">end</span></span>

hacerAlgoImportante decirHola
hacerAlgoImportante decirAdios
</code></pre><p><em>Resultado:</em></p>
<pre><code>¡Todo el mundo DETENGANSE!  Tengo algo que hacer...
hola
A todos: Está hecho.  Continuen con lo que estaban haciendo.<span class="hljs-comment">'</span>
¡Todo el mundo DETENGANSE!  Tengo algo que hacer...
adios
A todos: Está hecho.  Continuen con lo que estaban haciendo.<span class="hljs-comment">'</span>
</code></pre><p>Quizá esto no parezca muy fabuloso... pero lo es. :-)
Es común en programacion tener requerimientos estrictos acerca de
que debe ser hecho y cuando. Si quieres salvar un archivo, por ejemplo,
tienes que abrir el archivo, escribir la informacion que quieres que
contenga y luego cerrar el archivo. El olvido de cerrar el archivo puede
traer malas consecuencias. Pero cada vez que quieras salvar un archivo
o cargar uno tienes que hacer lo mismo: abrir el archivo, hacer lo que
<em>realmente</em> quieres hacer y luego cerrar el archivo. Esto es tedioso
y fácil de olvidar. En Ruby, guardar (o cargar) archivos trabaja en forma similar
al código anterior, entonces no tienes que preocuparte por nada más que por
lo que quieres guardar(o cargar). (En el próximo capitulo mostraré donde
encontrar información sobre guardar y cargar archivos.)</p>
<p>También puedes escribir métodos que determinan cuantas veces, o incluso <em>si</em>
deben llamar a un proc. Aquí hay un método el cual podría llamar al proc la mitad de veces
y otro el cual lo llamará el doble de veces:</p>
<p><em>Código:</em></p>
<pre><code>def puedeHacerse unProc
  <span class="hljs-keyword">if</span> rand(<span class="hljs-number">2</span>) == <span class="hljs-number">0</span>
    unProc.call
  <span class="hljs-function"><span class="hljs-keyword">end</span></span>
<span class="hljs-function"><span class="hljs-keyword">end</span></span>

def hacerDosVeces unProc
  unProc.call
  unProc.call
<span class="hljs-function"><span class="hljs-keyword">end</span></span>

parpadeo = Proc.<span class="hljs-built_in">new</span> <span class="hljs-built_in">do</span>
  puts <span class="hljs-string">'&lt;parpadeo&gt;'</span>
<span class="hljs-function"><span class="hljs-keyword">end</span></span>

mirada = Proc.<span class="hljs-built_in">new</span> <span class="hljs-built_in">do</span>
  puts <span class="hljs-string">'&lt;mirada&gt;'</span>
<span class="hljs-function"><span class="hljs-keyword">end</span></span>

puedeHacerse parpadeo
puedeHacerse mirada
hacerDosVeces parpadeo
hacerDosVeces mirada
</code></pre><p><em>Resultado:</em></p>
<pre><code><span class="hljs-tag">&lt;<span class="hljs-title">mirada</span>&gt;</span>
<span class="hljs-tag">&lt;<span class="hljs-title">parpadeo</span>&gt;</span>
<span class="hljs-tag">&lt;<span class="hljs-title">parpadeo</span>&gt;</span>
<span class="hljs-tag">&lt;<span class="hljs-title">mirada</span>&gt;</span>
<span class="hljs-tag">&lt;<span class="hljs-title">mirada</span>&gt;</span>
</code></pre><p>(Si ejecutas el programa un par de veces, verás que la salida cambiará) Estos son
algunos de los casos comunes de uso de procs lo que le permite hacer cosas, utilizando
simplemente métodos no podriamos hacerlo. Seguramente, podrías escribir un método para
que parpadee dos veces, pero no podrías escribir uno que haga <em>algo</em> dos veces!</p>
<p>Antes de continuar, vamos a ver un último ejemplo. Los procs que
hemos visto son bastante similares. Es tiempo de ver algo diferente,
entonces vamos a ver cuanto un método depende de un proc pasado a este.
Nuestro método tomará algun objeto y un proc, y llamará a este proc
sobre este objeto. Si el proc retorna falso, terminamos; en caso contrario
llamaremos al proc con el objeto. Continuaremos haciendo esto hasta
que el proc retorne falso (esto es mejor, o el programa finalizará con
error). El método retornará el último valor no falso retornado por
el proc.</p>
<p><em>Código:</em></p>
<pre><code>def hacerHastaQueSeaFalso primeraentrada, unProc
  entrada  = primeraentrada
  salida = primeraentrada

  <span class="hljs-keyword">while</span> salida
    entrada  = salida
    salida = unProc.call entrada
  <span class="hljs-function"><span class="hljs-keyword">end</span></span>

  entrada
<span class="hljs-function"><span class="hljs-keyword">end</span></span>

construirMatrizDeCuadrados = Proc.<span class="hljs-built_in">new</span> <span class="hljs-built_in">do</span> |array|
  ultimonumero = array.<span class="hljs-keyword">last</span>
  <span class="hljs-keyword">if</span> ultimonumero &lt;= <span class="hljs-number">0</span>
    <span class="hljs-constant">false</span>
  <span class="hljs-keyword">else</span>
    array.pop                         <span class="hljs-comment">#  Quitar el último número...</span>
    array.push ultimonumero*ultimonumero  <span class="hljs-comment">#  ...y reemplazar este con el último número elevado al cuadrado...</span>
    array.push ultimonumero-<span class="hljs-number">1</span>           <span class="hljs-comment">#  ...seguido por un número menor.</span>
  <span class="hljs-function"><span class="hljs-keyword">end</span></span>
<span class="hljs-function"><span class="hljs-keyword">end</span></span>

siempreFalso = Proc.<span class="hljs-built_in">new</span> <span class="hljs-built_in">do</span> |soloIgnorame|
  <span class="hljs-constant">false</span>
<span class="hljs-function"><span class="hljs-keyword">end</span></span>

puts hacerHastaQueSeaFalso([<span class="hljs-number">5</span>], construirMatrizDeCuadrados).inspect
puts hacerHastaQueSeaFalso(<span class="hljs-string">'Estoy escribiendo esto a las 3:00 am; ¡alguien que lo finalice!'</span>, siempreFalso)
</code></pre><p><em>Resultado:</em></p>
<pre><code><span class="hljs-attr_selector">[25, 16, 9, 4, 1, 0]</span>
<span class="hljs-tag">Estoy</span> <span class="hljs-tag">escribiendo</span> <span class="hljs-tag">esto</span> <span class="hljs-tag">a</span> <span class="hljs-tag">las</span> 3<span class="hljs-pseudo">:00</span> <span class="hljs-tag">am</span>, ¡<span class="hljs-tag">alguien</span> <span class="hljs-tag">que</span> <span class="hljs-tag">lo</span> <span class="hljs-tag">finalice</span>!
</code></pre><p>Está bien, este es un ejemplo bastante raro, debo admitirlo. Pero esto muestra como
actúa diferente nuestro método cuando le damos diferentes procs.</p>
<p>El método <code>inspect</code> es muy parecido a <code>to_s</code> , salvo que la cadena que devuelve
trata de mostrar el código ruby para crear el objeto que pasó. Aquí se nos muestra
toda la matriz devuelta por nuestra primera llamada a <code>haceHastaQueSeaFalso</code>. Además, notamos
que nosotros no procesamos el <code>0</code> al final de la matriz, porque <code>0</code>
al cuadrado sigue siendo <code>0</code> y por lo tanto no tenía que hacerse. Y puesto
que <code>siempreFalso</code> era siempre <code>false</code>,<code>hacerHastaQueSeaFalso</code> no hace nada la segunda vez que
se llama sino que retorna lo que se le pasó.</p>
<h2 id="m-todos-que-retornan-procedimientos">Métodos que retornan Procedimientos</h2>
<p>Una de las cosas interesantes que puedes hacer con procs es crearlos
en los métodos y devolverlos. Esto permite realizar cosas grandiosas de
programación (cosas con nombres impresionantes, como <em>lazy evaluation</em>,
<em>estructuras de datos infinitas</em> y <em>currying</em>), pero el hecho es que
casi nunca hago esto en la práctica, ni puedo recordar haber visto a
nadie hacer esto en su código. Creo que es el tipo de cosas que no
suelen llegar a tener que hacer en Ruby, o tal vez simplemente Ruby te
anima a buscar otras soluciones, yo no lo sé. En cualquier caso, sólo
voy a referirme a esto brevemente.</p>
<p>En este ejemplo, <code>compose</code> toma dos procs y devuelve un proc nuevo que,
cuando se le llama, llama al primer proc y pasa el resultado en el segundo
proc.</p>
<p><em>Código:</em></p>
<pre><code>def compone proc1, proc2
  Proc.<span class="hljs-built_in">new</span> <span class="hljs-built_in">do</span> |x|
    proc2.call(proc1.call(x))
  <span class="hljs-function"><span class="hljs-keyword">end</span></span>
<span class="hljs-function"><span class="hljs-keyword">end</span></span>

cuadrado = Proc.<span class="hljs-built_in">new</span> <span class="hljs-built_in">do</span> |x|
  x * x
<span class="hljs-function"><span class="hljs-keyword">end</span></span>

doble = Proc.<span class="hljs-built_in">new</span> <span class="hljs-built_in">do</span> |x|
  x + x
<span class="hljs-function"><span class="hljs-keyword">end</span></span>

dobleYCuadrado = compone doble, cuadrado
cuadradoYDoble = compone cuadrado, doble

puts dobleYCuadrado.call(<span class="hljs-number">5</span>)
puts cuadradoYDoble.call(<span class="hljs-number">5</span>)

*Resultado:*

<span class="hljs-number">100</span>
<span class="hljs-number">50</span>
</code></pre><p>Ten en cuenta que la llamada a <code>proc1</code> tenía que estar dentro de los
paréntesis para <code>proc2</code> con el fin de que se haga en primer lugar.</p>
<h2 id="pasando-bloques-no-procedimientos-en-los-m-todos">Pasando Bloques (no Procedimientos) en los Métodos</h2>
<p>Ok, esto es académicamente interesante pero también algo difícil de usar.
Gran parte del problema es que hay tres pasos que se tienen que realizar
(definir el método, hacer el proc y llamar al método con el proc), parecería
que solo debería haber dos (definir el método y pasar el <em>bloque</em> correcto dentro
del método, sin necesidad de usar un proc) ya que la mayoría de las veces usted
no desea utilizar el proc/bloque después de pasarlo al método. Bueno, no lo sabes,
Ruby tiene todo resuelto por nosotros! De hecho, ya ha estabas haciendolo cada
vez que utilizabas iteradores.</p>
<p>Te mostraré primero un ejemplo rápido, y luego vamos a hablar de ello.</p>
<p><em>Código:</em></p>
<pre><code><span class="hljs-class"><span class="hljs-keyword">class</span> <span class="hljs-title">Array</span></span>
  <span class="hljs-function"><span class="hljs-keyword">def</span> </span>cadaPar(&amp;fueBloque_ahoraesProc)
    esPar = <span class="hljs-keyword">true</span>  <span class="hljs-comment">#  Empezamos con "true" porque las matrices comienzan con 0</span>

    <span class="hljs-keyword">self</span>.each <span class="hljs-keyword">do</span> |objeto|
      <span class="hljs-keyword">if</span> esPar
        fueBloque_ahoraesProc.call objeto
      <span class="hljs-keyword">end</span>

      esPar = (<span class="hljs-keyword">not</span> esPar)  <span class="hljs-comment">#  Cambiar de pares a impares o viceversa</span>
    <span class="hljs-keyword">end</span>
  <span class="hljs-keyword">end</span>

<span class="hljs-keyword">end</span>

[<span class="hljs-string">'manzana'</span>, <span class="hljs-string">'manzana podrida'</span>, <span class="hljs-string">'cereza'</span>, <span class="hljs-string">'durian'</span>].cadaPar <span class="hljs-keyword">do</span> |fruta|
  puts <span class="hljs-string">'¡Yum!  Me encantan los pasteles de '</span>+fruta+<span class="hljs-string">', ¿no?'</span>
<span class="hljs-keyword">end</span>

<span class="hljs-comment">#  Recuerda,, estamos tratando de conseguir los numeros pares</span>
<span class="hljs-comment">#  de la Matriz.</span>

[<span class="hljs-number">1</span>, <span class="hljs-number">2</span>, <span class="hljs-number">3</span>, <span class="hljs-number">4</span>, <span class="hljs-number">5</span>].cadaPar <span class="hljs-keyword">do</span> |bolaImpar|
  puts bolaImpar.to_s+<span class="hljs-string">' NO es un número par!'</span>
<span class="hljs-keyword">end</span>
</code></pre><p><em>Resultado:</em></p>
<pre><code>¡<span class="hljs-variable">Yum</span><span class="hljs-exclamation_mark">!</span> <span class="hljs-variable">Me</span> <span class="hljs-function_or_atom">encantan</span> <span class="hljs-function_or_atom">los</span> <span class="hljs-function_or_atom">pasteles</span> <span class="hljs-function_or_atom">de</span> <span class="hljs-function_or_atom">manzana</span>, ¿<span class="hljs-function_or_atom">no</span>?
¡<span class="hljs-variable">Yum</span><span class="hljs-exclamation_mark">!</span> <span class="hljs-variable">Me</span> <span class="hljs-function_or_atom">encanta</span> <span class="hljs-function_or_atom">pasteles</span> <span class="hljs-function_or_atom">de</span> <span class="hljs-function_or_atom">cereza</span>, ¿<span class="hljs-function_or_atom">no</span>?
<span class="hljs-number">1</span> <span class="hljs-variable">NO</span> <span class="hljs-function_or_atom">es</span> <span class="hljs-function_or_atom">un</span> <span class="hljs-function_or_atom">n</span>ú<span class="hljs-function_or_atom">mero</span> <span class="hljs-function_or_atom">par</span><span class="hljs-exclamation_mark">!</span>
<span class="hljs-number">3</span> <span class="hljs-variable">NO</span> <span class="hljs-function_or_atom">es</span> <span class="hljs-function_or_atom">un</span> <span class="hljs-function_or_atom">n</span>ú<span class="hljs-function_or_atom">mero</span> <span class="hljs-function_or_atom">par</span><span class="hljs-exclamation_mark">!</span>
<span class="hljs-number">5</span> <span class="hljs-variable">NO</span> <span class="hljs-function_or_atom">es</span> <span class="hljs-function_or_atom">un</span> <span class="hljs-function_or_atom">n</span>ú<span class="hljs-function_or_atom">mero</span> <span class="hljs-function_or_atom">par</span><span class="hljs-exclamation_mark">!</span>
</code></pre><p>Así que para pasar un bloque de <code>cadaPar</code> todo lo que tenía que hacer
era pegar el bloque después del método. Puedes pasar un bloque
dentro de cualquier método de esta manera, aunque muchos métodos simplemente
ignorarán el bloque. Con el fin de hacer que tu método <em>no</em> ignore el bloque
debes apoderarse de él y convertirlo en un proc y poner el nombre del proc
al final de la lista de parámetros de tu método precedida por el signo <code>&amp;</code>.
Así que esa parte es un poco difícil pero no demasiado y sólo tienes que
hacer esto una vez (cuando se define el método). A continuación, puedes
utilizar el método una y otra vez al igual que los métodos que reciben bloques como
<code>each</code> y <code>times</code>. (Recuerda que con <code>5.times</code> ¿hacemos ...?)</p>
<p>Si estás confundido, sólo recuerda lo que <code>cadaPar</code> se supone que debe hacer:
llamar al bloque pasado con todos los demás elementos de la matriz. Una vez que lo
hayas escrito y funciona no es necesario pensar en lo que está haciendo en
realidad internamente (&quot;¿qué bloque se llama cuando?&quot;) De hecho, esto es
exactamente por lo que escribimos métodos como éste: para que no tengamos
que pensar de nuevo en cómo trabajan. Nos limitamos a usarlos.</p>
<p>Recuerdo una vez que quería ser capaz de medir la duración de distintas secciones
de un programa. (Esto también se conoce como <em>profiling</em>.) Así que escribí un
método que toma la hora antes de ejecutar el código, ejecuta y luego toma la hora
al final para obtener la diferencia. No puedo encontrar el código en este momento,
pero no lo necesito, ya que probablemente fue algo como esto:</p>
<p><em>Código:</em></p>
<pre><code>def profile descripcionDeBloque, &amp;bloque
  inicioHora = Time.now

  bloque.call

  duracion = Time.now - inicioHora

  puts descripcionDeBloque+<span class="hljs-string">':  '</span>+duracion.to_s+<span class="hljs-string">' segundos'</span>
<span class="hljs-function"><span class="hljs-keyword">end</span></span>

profile <span class="hljs-string">'25000 duplicaciones'</span> <span class="hljs-built_in">do</span>
  numero = <span class="hljs-number">1</span>

  <span class="hljs-number">25000.</span>times <span class="hljs-built_in">do</span>
    numero = numero + numero
  <span class="hljs-function"><span class="hljs-keyword">end</span></span>

  puts numero.to_s.<span class="hljs-built_in">length</span>.to_s+<span class="hljs-string">' digitos'</span>  <span class="hljs-comment">#  El numero de digitos en este numero ENORME.</span>
<span class="hljs-function"><span class="hljs-keyword">end</span></span>

profile <span class="hljs-string">'contar hasta un millon'</span> <span class="hljs-built_in">do</span>
  numero = <span class="hljs-number">0</span>

  <span class="hljs-number">1000000.</span>times <span class="hljs-built_in">do</span>
    numero = numero + <span class="hljs-number">1</span>
  <span class="hljs-function"><span class="hljs-keyword">end</span></span>
<span class="hljs-function"><span class="hljs-keyword">end</span></span>
</code></pre><p><em>Resultado:</em></p>
<pre><code>7526 digitos
25000 duplicaciones:  0.246768 segundos
contar hasta un millon:  0.90245 segundos
</code></pre><p>¡Qué sencillo! Qué elegante! Con ese pequeño método puedo fácilmente saber
cuanto tiempo demora parte de cualquier programa que quiero, solo ejecuto el
código en un bloque y se lo envió a <code>profile</code>. ¿Qué podría ser más sencillo? En
la mayoría de los lenguajes, yo tendría que añadir explícitamente el código
de tiempo (lo que está dentro de <code>profile</code>) dentro de cada sección que deseo
medir. En Ruby, sin embargo, tengo que mantener todo en un solo lugar, y (más
importante) ¡fuera de mi camino!</p>
<h2 id="algunas-cosas-por-intentar">Algunas cosas por intentar</h2>
<ul>
<li><p><em>Reloj del Abuelo</em>. Escriba un método que toma un bloque y lo llame una vez
por cada hora que ha pasado hoy. De esta manera, si paso al bloque <code>do puts &#39;DONG!&#39; end</code>
la campana debería sonar (más o menos) como un reloj de péndulo. Pon a prueba
tu método con unas pocos bloques (incluyendo la que acabo de darte). <strong><em>Sugerencia:</em></strong>
Puede utilizar <code>Time.now.hour</code> para obtener la hora actual. Sin embargo, este
devuelve un número entre <code>0</code> y <code>23</code>, por lo que tendrá que modificar los números
a fin de obtener valores clásicos de un reloj de este tipo (<code>1</code> <em>al</em> <code>12</code>).</p>
</li>
<li><p><em>Program Logger</em>. Escribir un método llamado <code>log</code>, la cual toma una
cadena de un bloque y, por supuesto, el bloque. Al igual que <code>doSelfImportantly</code>,
deberá <code>puts</code> una cadena diciendo que se ha iniciado el bloque, y otra cadena
diciendo que ha terminado el bloque y también debe decir lo que el bloque retornó.
Pon a prueba tu método mediante el envío de un bloque de código. En el interior
del bloque, pon <em>otra</em> llamada a <code>log</code> pasando otro bloque. (Esto se llama <em>anidación</em>.)
En otras palabras, su salida debería ser algo como esto:</p>
</li>
</ul>
<p><em>Listado:</em></p>
<pre><code>A partir del <span class="hljs-string">"bloque externo"</span> <span class="hljs-keyword">...</span>
A partir de <span class="hljs-string">"un bloque pequeño"</span> <span class="hljs-keyword">...</span>
<span class="hljs-keyword">...</span> <span class="hljs-string">"Algún pequeño bloque"</span> terminó, regreso: <span class="hljs-number">5</span>
A partir del <span class="hljs-string">"otro bloque"</span> <span class="hljs-keyword">...</span>
<span class="hljs-keyword">...</span> <span class="hljs-string">"Otro bloque"</span>, terminó, regreso: me gusta la comida tailandesa!
<span class="hljs-keyword">...</span> <span class="hljs-string">"Bloque exterior"</span>, terminó, regreso: false
</code></pre><ul>
<li><em>Mejores Logger</em>. El resultado del último logger fue un poco difícil de leer y
debería empeorar cuanto más se use. Sería mucho más fácil de leer si se indenta
las líneas en los bloques interiores. Para ello, tendrás que llevar la cuenta
de cuán profundamente estás anidado cada vez que el logger quiere escribir algo.
Para ello, utilice una <em>variable global</em>, una variable que se puede ver en
cualquier parte de tu código. Para hacer una variable global, sólo precede a
su nombre con el símbolo <code>$</code> , como los siguientes:  <code>$global</code>, <code>$nestingDepth</code> y
<code>$bigTopPeeWee</code>. Al final, el logger debe generar un código como este:</li>
</ul>
<p><em>Listado:</em></p>
<pre><code>A partir del <span class="hljs-string">"bloque exterior"</span> <span class="hljs-keyword">...</span>
  A partir de <span class="hljs-string">"un bloque pequeño"</span> <span class="hljs-keyword">...</span>
    A partir del <span class="hljs-string">"pequeñito-minúsculo bloque"</span> <span class="hljs-keyword">...</span>
    <span class="hljs-keyword">...</span> <span class="hljs-string">"pequeñito-minúsculo bloque"</span> terminó, regreso: un montón de amor
  <span class="hljs-keyword">...</span> <span class="hljs-string">"un bloque pequeño"</span> terminó, regreso: <span class="hljs-number">42</span>
  A partir del <span class="hljs-string">"otro bloque"</span> <span class="hljs-keyword">...</span>
  <span class="hljs-keyword">...</span> <span class="hljs-string">"otro bloque"</span>, terminó, regreso: me encanta la comida india!
<span class="hljs-keyword">...</span> <span class="hljs-string">"bloque exterior"</span>, terminó, regreso: true
</code></pre><p>Bueno, eso es todo lo que vas a aprender de este tutorial. ¡Felicitaciones!
¡Has aprendido un montón! Tal vez no tienes ganas de recordar todo, o te has
saltado unas partes ... Realmente, eso está bien. La programación no es sobre
lo que sabes, se trata de lo que puedes imaginar. Como siempre que se sepa
dónde encontrar las cosas que habías olvidado, lo estás haciendo muy bien.
¡Espero que no pienses que escribí todo esto sin revisar estas cosas a cada minuto!
Porque lo hice. Yo también recibí un montón de ayuda con el código de los ejemplos
de este tutorial. Pero, ¿dónde estaba <em>yo</em> buscando estas cosas y donde <em>yo</em> pido
ayuda?.</p>
<p><a href="/capitulos/11-despues-de-esta-guia.html">Te voy a enseñar...</a></p>

                    
                    </section>
                
                </div>
            </div>
        </div>

        
        <a href="../capitulos/clases.html" class="navigation navigation-prev"><i class="fa fa-angle-left"></i></a>
        
        
        <a href="../capitulos/fin.html" class="navigation navigation-next"><i class="fa fa-angle-right"></i></a>
        
    </div>
</div>

        
        <link rel="stylesheet" href="../gitbook/style.css">
        
        
        <script src="https://cdnjs.cloudflare.com/ajax/libs/ace/1.1.3/ace.js"></script>
        <script src="https://cdnjs.cloudflare.com/ajax/libs/ace/1.1.3/mode-javascript.js"></script>
        <script src="../gitbook/jsrepl/jsrepl.js" id="jsrepl-script"></script>
        <script src="../gitbook/app.js"></script>
        
    </body>
</html>
